<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3-Digit Guess Game - Online Multiplayer</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: 'Inter', 'Segoe UI', sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 2.5rem;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
      width: 100%;
      max-width: 550px;
      transition: all 0.3s ease;
    }

    .container:hover {
      transform: translateY(-2px);
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
    }

    h1, h2, h3 {
      margin: 0 0 1.5rem 0;
      text-align: center;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h1 { font-size: 2.2rem; font-weight: 700; }
    h2 { font-size: 1.8rem; font-weight: 600; }
    h3 { font-size: 1.4rem; font-weight: 500; }

    input {
      padding: 1rem;
      margin-bottom: 1rem;
      width: 100%;
      border: 2px solid #e1e5e9;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
      background: rgba(255, 255, 255, 0.8);
    }

    input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: translateY(-1px);
    }

    button {
      width: 100%;
      padding: 1rem;
      font-size: 1rem;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 0.5rem;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .button-group button {
      margin-bottom: 0;
    }

    .log {
      margin-top: 1.5rem;
      background: rgba(249, 249, 249, 0.8);
      border-radius: 15px;
      padding: 1.5rem;
      height: 250px;
      overflow-y: auto;
      font-size: 0.95rem;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .log div {
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      animation: fadeIn 0.3s ease;
    }

    .log div:last-child {
      border-bottom: none;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hidden {
      display: none;
    }

    .success {
      color: #22c55e;
      font-weight: bold;
      background: rgba(34, 197, 94, 0.1);
      padding: 1rem;
      border-radius: 10px;
      text-align: center;
    }

    .status {
      text-align: center;
      padding: 1rem;
      border-radius: 10px;
      margin-bottom: 1rem;
      font-weight: 500;
    }

    .status.connected {
      background: rgba(34, 197, 94, 0.1);
      color: #22c55e;
    }

    .status.connecting {
      background: rgba(251, 191, 36, 0.1);
      color: #f59e0b;
    }

    .status.disconnected {
      background: rgba(239, 68, 68, 0.1);
      color: #ef4444;
    }

    .room-code {
      font-family: 'Courier New', monospace;
      font-size: 1.2rem;
      font-weight: bold;
      text-align: center;
      padding: 1rem;
      background: rgba(102, 126, 234, 0.1);
      border-radius: 10px;
      margin: 1rem 0;
      letter-spacing: 2px;
    }

    .turn-indicator {
      text-align: center;
      padding: 1rem;
      border-radius: 12px;
      margin-bottom: 1rem;
      font-weight: 600;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      border: 2px solid rgba(102, 126, 234, 0.2);
    }

    .play-again-section {
      text-align: center;
      padding: 1.5rem;
      background: rgba(102, 126, 234, 0.05);
      border-radius: 15px;
      margin: 1rem 0;
      border: 2px solid rgba(102, 126, 234, 0.1);
    }

    .play-again-waiting {
      background: rgba(251, 191, 36, 0.05);
      border-color: rgba(251, 191, 36, 0.2);
    }

    .play-again-ready {
      background: rgba(34, 197, 94, 0.05);
      border-color: rgba(34, 197, 94, 0.2);
    }

    .play-again-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .play-again-status {
      font-size: 1rem;
      margin-bottom: 1rem;
      padding: 0.5rem;
      border-radius: 8px;
    }

    .status-waiting {
      color: #f59e0b;
      background: rgba(251, 191, 36, 0.1);
    }

    .status-ready {
      color: #22c55e;
      background: rgba(34, 197, 94, 0.1);
    }

    @media (max-width: 600px) {
      .container {
        padding: 1.5rem;
        margin: 10px;
      }
      
      .button-group {
        flex-direction: column;
        gap: 0.5rem;
      }
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>🎯 3-Digit Guessing Game</h1>

    <!-- Connection Setup -->
    <div id="connection-setup">
      <div class="button-group">
        <button onclick="createRoom()">Create Room</button>
        <button onclick="showJoinRoom()">Join Room</button>
      </div>
      <button onclick="playLocal()">Play Locally</button>
    </div>

    <!-- Join Room -->
    <div id="join-room" class="hidden">
      <input type="text" id="room-code-input" placeholder="Enter Room Code" maxlength="6">
      <button onclick="joinRoom()">Join Room</button>
      <button onclick="backToMenu()">Back</button>
    </div>

    <!-- Room Display -->
    <div id="room-display" class="hidden">
      <div class="status" id="connection-status">Connecting...</div>
      <div class="room-code" id="room-code-display"></div>
      <p style="text-align: center; color: #666;">Share this code with your friend!</p>
      <button onclick="backToMenu()" id="back-btn">Back to Menu</button>
    </div>

    <!-- Local Game Setup -->
    <div id="setup" class="hidden">
      <h2>Game Setup</h2>
      <input type="password" id="p1-secret" maxlength="3" placeholder="Player 1 Secret (3 digits)">
      <input type="password" id="p2-secret" maxlength="3" placeholder="Player 2 Secret (3 digits)">
      <button onclick="startGame()">Start Game</button>
      <button onclick="backToMenu()">Back</button>
    </div>

    <!-- Online Game Setup -->
    <div id="online-setup" class="hidden">
      <h2>Set Your Secret</h2>
      <input type="password" id="my-secret" maxlength="3" placeholder="Your 3-digit secret">
      <button onclick="setSecret()">Ready to Play!</button>
      <div class="status" id="waiting-status" style="display: none;">Waiting for opponent...</div>
    </div>

    <!-- Game Area -->
    <div id="game-area" class="hidden">
      <div class="turn-indicator" id="turn-indicator">Player 1's Turn</div>
      <input type="text" id="guess" placeholder="Enter your 3-digit guess" maxlength="3">
      <button onclick="makeGuess()" id="guess-btn">Make Guess</button>
      
      <!-- Play Again Section -->
      <div id="play-again-section" class="play-again-section hidden">
        <div class="play-again-title">🎮 Game Over!</div>
        <div id="play-again-status" class="play-again-status">Ready to play again?</div>
        <div class="button-group" style="flex-direction: column; gap: 0.5rem;">
          <button onclick="requestPlayAgain()" id="play-again-btn">Play Again</button>
          <button onclick="backToMenu()" id="game-back-btn">Back to Menu</button>
        </div>
      </div>

      <div class="log" id="log"></div>
    </div>
  </div>

  <script>
    let secrets = {};
    let turn = 1;
    let gameMode = 'local'; // 'local' or 'online'
    let isOnline = false;
    let peer = null;
    let connection = null;
    let myPlayerId = null;
    let roomCode = null;
    let isConnected = false;
    let opponentReady = false;
    let bothPlayersConnected = false;
    let gameState = {
      secrets: {},
      turn: 1,
      gameStarted: false,
      playerReady: {},
      logs: []
    };

    let playAgainRequested = false;
    let opponentPlayAgainRequested = false;

    // Message types for communication
    const MSG_TYPES = {
      SECRET_SET: 'secret_set',
      GUESS_MADE: 'guess_made',
      GAME_START: 'game_start',
      PLAYER_READY: 'player_ready',
      PLAYER_JOINED: 'player_joined',
      TURN_CHANGE: 'turn_change',
      PLAY_AGAIN_REQUEST: 'play_again_request',
      PLAY_AGAIN_ACCEPTED: 'play_again_accepted'
    };

    // Simple signaling simulation using localStorage for cross-tab communication
    function generateRoomCode() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    function sendMessage(type, data) {
      if (gameMode === 'online') {
        const message = { 
          type, 
          data, 
          playerId: myPlayerId,
          roomCode: roomCode,
          timestamp: Date.now()
        };
        
        console.log('Sending message:', message);
        
        // Use localStorage to simulate real-time communication between tabs/windows
        localStorage.setItem(`game_message_${roomCode}`, JSON.stringify(message));
        
        // Remove the setTimeout that was causing duplicate messages
        // Only real cross-tab communication through localStorage storage event
      }
    }

    function handleIncomingMessage(message) {
      if (message.playerId === myPlayerId) return; // Don't process own messages
      if (message.roomCode !== roomCode) return; // Different room
      
      console.log('Received message:', message);
      
      switch (message.type) {
        case MSG_TYPES.PLAYER_JOINED:
          if (!bothPlayersConnected) {
            bothPlayersConnected = true;
            document.getElementById('connection-status').textContent = 'Player joined! Ready to play.';
            document.getElementById('connection-status').className = 'status connected';
            startOnlineSetup();
          }
          break;
          
        case MSG_TYPES.SECRET_SET:
          // Store opponent's secret properly
          gameState.secrets[message.data.playerId] = message.data.secret;
          opponentReady = true;
          if (gameState.playerReady[myPlayerId]) {
            startOnlineGame();
          }
          break;
          
        case MSG_TYPES.GUESS_MADE:
          // Add opponent's guess to our log
          addLogEntry(message.data.playerName, message.data.guess, message.data.correct, message.data.secret, message.data.isWin);
          
          if (!message.data.isWin) {
            // Switch to my turn
            turn = myPlayerId;
            gameState.turn = turn;
            updateTurnIndicator();
          } else {
            // Game ended, show play again section
            showPlayAgainSection();
          }
          break;
          
        case MSG_TYPES.GAME_START:
          // Sync game state with opponent
          if (!gameState.gameStarted) {
            secrets = message.data.secrets;
            turn = message.data.turn;
            gameState.turn = turn;
            gameState.gameStarted = true;
            
            document.getElementById('online-setup').classList.add('hidden');
            document.getElementById('game-area').classList.remove('hidden');
            document.getElementById('log').innerHTML = '';
            updateTurnIndicator();
          }
          break;
          
        case MSG_TYPES.PLAY_AGAIN_REQUEST:
          // Opponent requested to play again
          opponentPlayAgainRequested = true;
          updatePlayAgainStatus();
          
          if (playAgainRequested) {
            // Both players want to play again
            startPlayAgain();
          }
          break;
          
        case MSG_TYPES.PLAY_AGAIN_ACCEPTED:
          // Both players agreed, start new game
          startPlayAgain();
          break;
      }
    }

    // Listen for localStorage changes (cross-tab communication)
    window.addEventListener('storage', function(e) {
      if (e.key && e.key.startsWith('game_message_') && e.newValue) {
        try {
          const message = JSON.parse(e.newValue);
          handleIncomingMessage(message);
        } catch (err) {
          console.error('Error parsing message:', err);
        }
      }
    });

    function createRoom() {
      roomCode = generateRoomCode();
      myPlayerId = 1;
      gameMode = 'online';
      isConnected = true;
      bothPlayersConnected = false;
      
      document.getElementById('connection-setup').classList.add('hidden');
      document.getElementById('room-display').classList.remove('hidden');
      document.getElementById('room-code-display').textContent = roomCode;
      document.getElementById('connection-status').textContent = 'Waiting for player to join...';
      document.getElementById('connection-status').className = 'status connecting';
      
      // Store room info in localStorage
      localStorage.setItem(`room_${roomCode}`, JSON.stringify({
        host: myPlayerId,
        created: Date.now(),
        players: [myPlayerId]
      }));
      
      // Don't auto-proceed, wait for actual player to join
      console.log('Room created, waiting for player 2...');
    }

    function showJoinRoom() {
      document.getElementById('connection-setup').classList.add('hidden');
      document.getElementById('join-room').classList.remove('hidden');
    }

    function joinRoom() {
      const code = document.getElementById('room-code-input').value.trim().toUpperCase();
      if (!code || code.length !== 6) {
        alert('Please enter a valid 6-character room code.');
        return;
      }
      
      // Check if room exists
      const roomData = localStorage.getItem(`room_${code}`);
      if (!roomData) {
        alert('Room not found. Please check the code and try again.');
        return;
      }
      
      roomCode = code;
      myPlayerId = 2;
      gameMode = 'online';
      isConnected = true;
      bothPlayersConnected = true;
      
      document.getElementById('join-room').classList.add('hidden');
      document.getElementById('room-display').classList.remove('hidden');
      document.getElementById('room-code-display').textContent = roomCode;
      document.getElementById('connection-status').textContent = 'Connecting to room...';
      document.getElementById('connection-status').className = 'status connecting';
      
      // Update room data
      try {
        const room = JSON.parse(roomData);
        room.players.push(myPlayerId);
        localStorage.setItem(`room_${roomCode}`, JSON.stringify(room));
      } catch (e) {
        console.error('Error updating room data:', e);
      }
      
      // Notify host that player joined
      sendMessage(MSG_TYPES.PLAYER_JOINED, { playerId: myPlayerId });
      
      setTimeout(() => {
        document.getElementById('connection-status').textContent = 'Connected! Ready to play.';
        document.getElementById('connection-status').className = 'status connected';
        startOnlineSetup();
      }, 1000);
    }

    function startOnlineSetup() {
      document.getElementById('room-display').classList.add('hidden');
      document.getElementById('online-setup').classList.remove('hidden');
    }

    function playLocal() {
      gameMode = 'local';
      document.getElementById('connection-setup').classList.add('hidden');
      document.getElementById('setup').classList.remove('hidden');
    }

    function backToMenu() {
      // Clean up room data if we created it
      if (roomCode && myPlayerId === 1) {
        localStorage.removeItem(`room_${roomCode}`);
      }
      
      // Reset all states
      secrets = {};
      turn = 1;
      isConnected = false;
      opponentReady = false;
      bothPlayersConnected = false;
      gameState = { secrets: {}, turn: 1, gameStarted: false, playerReady: {}, logs: [] };
      
      // Hide all sections
      document.querySelectorAll('.container > div').forEach(div => {
        div.classList.add('hidden');
      });
      
      // Show main menu
      document.getElementById('connection-setup').classList.remove('hidden');
      
      // Reset inputs
      document.getElementById('guess').disabled = false;
      document.getElementById('guess').value = '';
      document.getElementById('log').innerHTML = '';
      document.getElementById('room-code-input').value = '';
      document.getElementById('my-secret').value = '';
    }

    function setSecret() {
      const secret = document.getElementById('my-secret').value.trim();
      if (!/^\d{3}$/.test(secret)) {
        alert("Secret must be a valid 3-digit number.");
        return;
      }

      gameState.secrets[myPlayerId] = secret;
      gameState.playerReady[myPlayerId] = true;
      
      document.getElementById('waiting-status').style.display = 'block';
      document.getElementById('waiting-status').textContent = 'Waiting for opponent to set their secret...';
      
      // Send secret to opponent (include the actual secret)
      sendMessage(MSG_TYPES.SECRET_SET, { 
        playerId: myPlayerId, 
        secret: secret,
        ready: true 
      });
      
      // If opponent is already ready, start game
      if (opponentReady) {
        startOnlineGame();
      }
    }

    function generateRandomSecret() {
      return Math.floor(100 + Math.random() * 900).toString();
    }

    function startOnlineGame() {
      if (!gameState.playerReady[myPlayerId] || !opponentReady) {
        return; // Wait for both players to be ready
      }
      
      // Ensure both secrets are set
      const opponentId = myPlayerId === 1 ? 2 : 1;
      if (!gameState.secrets[opponentId]) {
        return; // Wait for opponent's secret
      }
      
      secrets = {
        1: gameState.secrets[2], // Player 1 guesses Player 2's secret
        2: gameState.secrets[1]  // Player 2 guesses Player 1's secret
      };
      
      // Player 1 always starts
      turn = 1;
      gameState.turn = 1;
      gameState.gameStarted = true;
      
      document.getElementById('online-setup').classList.add('hidden');
      document.getElementById('game-area').classList.remove('hidden');
      
      // Clear any existing logs
      document.getElementById('log').innerHTML = '';
      
      updateTurnIndicator();
      
      // Send game start message with secrets
      sendMessage(MSG_TYPES.GAME_START, { 
        turn: turn, 
        gameStarted: true,
        secrets: secrets
      });
    }

    function startGame() {
      const p1 = document.getElementById('p1-secret').value.trim();
      const p2 = document.getElementById('p2-secret').value.trim();

      if (!/^\d{3}$/.test(p1) || !/^\d{3}$/.test(p2)) {
        alert("Both secrets must be valid 3-digit numbers.");
        return;
      }

      secrets = {
        1: p2,
        2: p1
      };

      turn = 1; // Player 1 always starts

      document.getElementById('setup').classList.add('hidden');
      document.getElementById('game-area').classList.remove('hidden');
      updateTurnIndicator();
    }

    function updateTurnIndicator() {
      const indicator = document.getElementById('turn-indicator');
      if (gameMode === 'online') {
        if (turn === myPlayerId) {
          indicator.textContent = "Your Turn";
          indicator.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(22, 163, 74, 0.1))';
          indicator.style.borderColor = 'rgba(34, 197, 94, 0.3)';
          document.getElementById('guess-btn').disabled = false;
          document.getElementById('guess').disabled = false;
        } else {
          indicator.textContent = "Opponent's Turn";
          indicator.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.1))';
          indicator.style.borderColor = 'rgba(239, 68, 68, 0.3)';
          document.getElementById('guess-btn').disabled = true;
          document.getElementById('guess').disabled = true;
        }
      } else {
        indicator.textContent = `Player ${turn}'s Turn`;
        indicator.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1))';
        indicator.style.borderColor = 'rgba(102, 126, 234, 0.2)';
        document.getElementById('guess-btn').disabled = false;
        document.getElementById('guess').disabled = false;
      }
    }

    function addLogEntry(playerName, guess, correct, secret, isWin) {
      const log = document.getElementById('log');
      const msg = `${playerName} guessed <b>${guess}</b> → ${correct} correct number(s).`;
      log.innerHTML += `<div>${msg}</div>`;
      
      if (isWin) {
        const winMsg = `🎉 ${playerName} wins! Secret was ${secret}.`;
        log.innerHTML += `<div class="success">${winMsg}</div>`;
      }
      
      log.scrollTop = log.scrollHeight;
    }

    function showPlayAgainSection() {
      document.getElementById('guess').disabled = true;
      document.getElementById('guess-btn').disabled = true;
      document.getElementById('play-again-section').classList.remove('hidden');
      
      // Reset play again states
      playAgainRequested = false;
      opponentPlayAgainRequested = false;
      updatePlayAgainStatus();
    }

    function requestPlayAgain() {
      playAgainRequested = true;
      document.getElementById('play-again-btn').disabled = true;
      
      if (gameMode === 'online') {
        // Send play again request to opponent
        sendMessage(MSG_TYPES.PLAY_AGAIN_REQUEST, { playerId: myPlayerId });
        
        if (opponentPlayAgainRequested) {
          // Both players want to play again
          sendMessage(MSG_TYPES.PLAY_AGAIN_ACCEPTED, { playerId: myPlayerId });
          startPlayAgain();
        } else {
          updatePlayAgainStatus();
        }
      } else {
        // Local game restart
        startPlayAgain();
      }
    }

    function updatePlayAgainStatus() {
      const statusDiv = document.getElementById('play-again-status');
      const sectionDiv = document.getElementById('play-again-section');
      
      if (gameMode === 'local') {
        statusDiv.textContent = 'Ready to play again?';
        statusDiv.className = 'play-again-status';
        sectionDiv.className = 'play-again-section';
      } else if (playAgainRequested && opponentPlayAgainRequested) {
        statusDiv.textContent = '🎉 Both players ready! Starting new game...';
        statusDiv.className = 'play-again-status status-ready';
        sectionDiv.className = 'play-again-section play-again-ready';
      } else if (playAgainRequested) {
        statusDiv.textContent = '⏳ Waiting for opponent to accept...';
        statusDiv.className = 'play-again-status status-waiting';
        sectionDiv.className = 'play-again-section play-again-waiting';
      } else if (opponentPlayAgainRequested) {
        statusDiv.textContent = '🔔 Opponent wants to play again!';
        statusDiv.className = 'play-again-status status-ready';
        sectionDiv.className = 'play-again-section play-again-ready';
      } else {
        statusDiv.textContent = 'Ready to play again?';
        statusDiv.className = 'play-again-status';
        sectionDiv.className = 'play-again-section';
      }
    }

    function startPlayAgain() {
      // Reset game state but keep connection info
      resetGameForPlayAgain();
      
      if (gameMode === 'online') {
        startOnlineSetup();
      } else {
        document.getElementById('game-area').classList.add('hidden');
        document.getElementById('setup').classList.remove('hidden');
      }
    }

    function resetGameForPlayAgain() {
      // Reset game state but keep connection info
      secrets = {};
      turn = 1;
      opponentReady = false;
      playAgainRequested = false;
      opponentPlayAgainRequested = false;
      gameState.secrets = {};
      gameState.turn = 1;
      gameState.gameStarted = false;
      gameState.playerReady = {};
      gameState.logs = [];
      
      // Reset UI elements
      document.getElementById('guess').disabled = false;
      document.getElementById('guess-btn').disabled = false;
      document.getElementById('guess').value = '';
      document.getElementById('log').innerHTML = '';
      document.getElementById('my-secret').value = '';
      document.getElementById('play-again-section').classList.add('hidden');
      document.getElementById('play-again-btn').disabled = false;
      document.getElementById('waiting-status').style.display = 'none';
    }

    function makeGuess() {
      if (gameMode === 'online' && turn !== myPlayerId) {
        return; // Not your turn
      }

      const guess = document.getElementById('guess').value.trim();
      if (!/^\d{3}$/.test(guess)) {
        alert("Enter a valid 3-digit number.");
        return;
      }

      const secret = secrets[turn];
      const guessArr = guess.split('');
      const secretArr = secret.split('');

      let guessCount = {};
      let secretCount = {};
      let correct = 0;

      // Count occurrences of each digit in both guess and secret
      guessArr.forEach(d => guessCount[d] = (guessCount[d] || 0) + 1);
      secretArr.forEach(d => secretCount[d] = (secretCount[d] || 0) + 1);

      // Count correct numbers - use minimum count between guess and secret for each digit
      // This ensures if secret has "111" and guess has "011", only 1 is counted (min of 1 and 3)
      for (let d in guessCount) {
        if (secretCount[d]) {
          correct += Math.min(guessCount[d], secretCount[d]);
        }
      }

      const playerName = gameMode === 'online' ? 'You' : `Player ${turn}`;
      const isWin = guess === secret; // Win only if exact match
      
      // Add to local log
      addLogEntry(playerName, guess, correct, secret, isWin);

      if (isWin) {
        showPlayAgainSection();
        
        // Send win message to opponent
        if (gameMode === 'online') {
          sendMessage(MSG_TYPES.GUESS_MADE, {
            playerName: 'Opponent',
            guess: guess,
            correct: correct,
            secret: secret,
            isWin: true
          });
        }
        return;
      }

      // Send guess info to opponent BEFORE switching turns
      if (gameMode === 'online') {
        sendMessage(MSG_TYPES.GUESS_MADE, {
          playerName: 'Opponent',
          guess: guess,
          correct: correct,
          secret: secret,
          isWin: false
        });
        
        // In online mode, disable inputs until opponent plays
        document.getElementById('guess-btn').disabled = true;
        document.getElementById('guess').disabled = true;
        
        // Update turn indicator to show "Waiting for opponent"
        const indicator = document.getElementById('turn-indicator');
        indicator.textContent = "Waiting for opponent...";
        indicator.style.background = 'linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.1))';
        indicator.style.borderColor = 'rgba(251, 191, 36, 0.3)';
        
      } else {
        // Switch turns only in local mode
        turn = turn === 1 ? 2 : 1;
        updateTurnIndicator();
      }
      
      document.getElementById('guess').value = '';
    }

    // Allow Enter key to submit guess
    document.getElementById('guess').addEventListener('keypress', function(e) {
      if (e.key === 'Enter' && !document.getElementById('guess-btn').disabled) {
        makeGuess();
      }
    });

    // Allow Enter key in room code input
    document.getElementById('room-code-input').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        joinRoom();
      }
    });

    // Allow Enter key in secret input
    document.getElementById('my-secret').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        setSecret();
      }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      if (roomCode && myPlayerId === 1) {
        localStorage.removeItem(`room_${roomCode}`);
      }
    });
  </script>

</body>
</html>
